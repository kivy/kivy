from kivy.properties import OptionProperty, ListProperty, StringProperty, \
                    ObjectProperty, NumericProperty, BooleanProperty
from kivy.graphics import Color, Line, SmoothLine, Ellipse
from kivy.event import EventDispatcher
from math import sqrt


class StrokePoint(object):
    '''
    Point
    ===================

    This class identifies a point with 2D coordinates x and y::

        # Create a Point
        pointA = Point(2,3)
        pointB = Point(4,5)
        distance = pointA.distance_to(pointB)
    '''

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        '''Override default Equals behaviour'''
        if isinstance(other, self.__class__):
            return (self.x == other.x and self.y == other.y)
        return False

    def __ne__(self, other):
        '''Define a non equality test'''
        return not self.__eq__(other)

    def __add__(self, p):
        '''Sum two points'''
        return StrokePoint(self.x + p.x, self.y + p.y)

    def __sub__(self, p):
        '''Substract two points'''
        return StrokePoint(self.x - p.x, self.y - p.y)

    def __mul__(self, scalar):
        '''Multiply a point to a scalar'''
        return StrokePoint(self.x * scalar, self.y * scalar)

    def __div__(self, scalar):
        '''Divide a point to a scalar'''
        return StrokePoint(self.x / scalar, self.y / scalar)

    def __str__(self):
        '''String representation'''
        return "(%s, %s)" % (self.x, self.y)

    def __repr__(self):
        '''print Point'''
        return "%s(%r, %r)" % (self.__class__.__name__, self.x, self.y)

    def clone(self):
        '''Return a copy of this point'''
        return StrokePoint(self.x, self.y)

    def distance_to(self, p):
        '''Calculate euclidean distance between two points.'''
        return sqrt(pow(self.x - p.x, 2.0) + pow(self.y - p.y, 2.0))

    def to_int(self):
        '''Make the point coordinates integers'''
        return StrokePoint(int(self.x), int(self.y))

    def to_float(self):
        '''Make the point coordinates float'''
        return StrokePoint(float(self.x), float(self.y))


class StrokeRect(object):
    '''
    StrokeRect
    ===================

    A rectangle implementation for getting bounds of objects::

        # Create a StrokeRect
        pointA = Point(2,3)
        pointB = Point(4,5)
        rect = StrokeRect(pointA, pointB)

    :Parameters:
        `p1`: StrokePoint
            Top left point of the rect.
        `p2`: StrokePoint
            Bottom right point of the rect.
    '''

    def __init__(self, p1, p2):
        self.pt1 = p1.to_float()
        self.pt2 = p2.to_float()
        self.left = min(self.pt1.x, self.pt2.x)
        self.top = max(self.pt1.y, self.pt2.y)
        self.right = max(self.pt1.x, self.pt2.x)
        self.bottom = min(self.pt1.y, self.pt2.y)
        self.width = self.right - self.left
        self.height = self.top - self.bottom

    def contains(self, p):
        ''' Returns whether or not a stroke_point is inside the rectangle '''
        return (self.left <= p.x <= self.right and
                self.top <= p.y <= self.bottom)

    def overlaps(self, rect):
        ''' Returns whether or not two strokerects overlap '''
        return (self.right > rect.left and self.left < rect.right and
                self.top < rect.bottom and self.bottom > rect.top)

    def top_left(self):
        '''Get the top-left corner stroke_point'''
        return StrokePoint(self.left, self.top)

    def bottom_right(self):
        '''Get the bottom right corner stroke_point'''
        return StrokePoint(self.right, self.bottom)

    def __str__(self):
        return "<Rect (%s,%s) - (%s,%s)>" % (self.left, self.top,
                                             self.right, self.bottom)

    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__,
                               StrokePoint(self.left, self.top),
                               StrokePoint(self.right, self.bottom))


class Stroke(EventDispatcher):
    '''
    Stroke
    ===================

    This class allows you to easily manipulate points on
    an InkCanvas, handles some basic drawing attributes and
    methods to filter and sample the original points list::

        # Create a Stroke and modify attributes
        stroke = Stroke(group_id=g)
        stroke._color = get_color_by_name('yellow')
        stroke.is_highlighter(0.5)
        stroke.points.append(StrokePoint(8.0, 9.0))

    .. warning::

        You won't really instantiate Strokes: it's more an example how
        InkCanvas handle strokes. Typically, you would use the list of strokes
        generated by InkCanvas for further processing.

    '''

    points = ListProperty([])
    '''List of points present on the Stroke.

    :attr:`points` is a :class:`~kivy.properties.ListProperty` with no
    elements initially.
    '''

    color = StringProperty('black')
    '''Color attribute of the stroke.

    :attr:`color` is a :class:`~kivy.properties.StringProperty` which by
    default is black.
    '''

    def __init__(self, group_id="", shortstraw_const=40.0, **kwargs):
        super(Stroke, self).__init__(**kwargs)
        self._color = (0.0, 0.0, 0.0, 1.0)
        self.group_id = group_id
        self.sampled_points = []
        self.shortstraw_const = shortstraw_const
        self.corners = []

    def __eq__(self, other):
        '''Override default Equals behaviour'''
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        '''Define a non equality test'''
        return not self.__eq__(other)

    def __str__(self):
        '''String representation'''
        cad = "["
        for point in self.points:
            cad += "(%s, %s)," % (point.x, point.y)
        return cad[:-1] + "]"

    def __repr__(self):
        '''print StrokePoint'''
        cad = "<%s> [" % (self.__class__.__name__)
        for point in self.points:
            cad += "(%r, %r)," % (point.x, point.y)
        return cad[:-1] + "]"

    def on_color(self, instance, color):
        '''Sets the color when the property change its value'''
        self._color = (0.0, 0.0, 0.0, 1.0)

    def is_highlighter(self, alfa):
        '''Change the alpha value in Color, for transparency'''
        if(len(self._color) == 4):
            self._color = (self._color[0], self._color[1], self._color[2])
        self._color = self._color + (alfa,)

    def visibility(self, visible):
        '''Defines whether or not a stroke is visible'''
        alfa = 1
        if len(self._color) == 4:
            alfa = self._color[3]
            self._color = (self._color[0], self._color[1], self._color[2])
        if not visible:
            self._color = self._color + (0,)
        else:
            self._color = self._color + (alfa,)

    def hit_test(self, p):
        '''Allows to know if a point is close to any of the strokes on canvas'''
        for point in self.points:
            dist = point.distance_to(p)
            if dist < 5.0:
                return True
        return False

    def get_bounds(self):
        '''Returns a StrokeRect which is a logical rectangle with
        the bounds of a stroke expressed as top, left, bottom, right
        values.
        :Returns:
            Stroke bounds as a StrokeRect. It is a
            :class:`~kivy.uix.inkcanvas.StrokeRect`
        '''
        minx = float("inf")
        maxx = float(0)
        miny = float("inf")
        maxy = float(0)
        for point in self.points:
            if point.x < minx:
                minx = point.x
            if point.x > maxx:
                maxx = point.x
            if point.y < miny:
                miny = point.y
            if point.y > maxy:
                maxy = point.y
        return StrokeRect(StrokePoint(minx, maxy), StrokePoint(maxx, miny))

    def filtering(self):
        '''Returns a copy of the points list with points that are not in
        a 2.0 radius from the original point. Distance is calculate by
        euclidean distance.
        ::
            >>> filtered_points = self.filtering()
            >>> self.points
            (22,10), (22,11), (25,15), (26,15), (30,11)
            >>> filtered_points
            (22, 10), (25,15), (30,11)
        .. versionadded:: 1.9.0
        '''
        clone_points = self.points[:]
        for i, point in enumerate(clone_points):
            if i > 0:
                d = clone_points[i - 1].distance_to(clone_points[i])
                if d <= 2.0:
                    clone_points.remove(point)
        return clone_points

    def sample_points(self):
        '''Stores a copy of the points list in self.sampled_points that
        were processed and their positions recalculated to be at the same
        euclidean distance.
        ::
            >>> self.sample_points()
            >>> self.points
            PointA, PointB, PointC, PointD, PointE
            >>> self.sampled_points
            PointA.distance_to(PointB) = PointB.distance_to(PointC) =
                    PointC.distance_to(PointD)
        .. versionadded:: 1.9.0
        '''
        bounds = self.get_bounds()
        S = bounds.top_left().distance_to(bounds.bottom_right()) / \
                             self.shortstraw_const
        D = 0.0
        self.sampled_points.append(self.points[0])
        clone_points = self.points[:]
        for i, point in enumerate(clone_points):
            if i > 0:
                d = clone_points[i - 1].distance_to(clone_points[i])
                if (D + d) >= S:
                    q = StrokePoint(-1, -1)
                    q.x = clone_points[i - 1].x + ((S - D) / d) * \
                                (clone_points[i].x - clone_points[i - 1].x)
                    q.y = clone_points[i - 1].y + ((S - D) / d) * \
                                (clone_points[i].y - clone_points[i - 1].y)
                    self.sampled_points.append(q)
                    clone_points.insert(i, q)
                    D = 0.0
                else:
                    D = D + d

    def get_graphics_line_points(self):
        '''Points in vertex instructions format for rendering'''
        linepoints = []
        for point in self.sampled_points:
            linepoints.extend([float(point.x), float(point.y)])
        return linepoints

    ''' Return a list of indexes where corners were found from the list
        of sampled points. '''
    def get_corners(self):
        self.corners.append(0)
        W = 3
        if len(self.sampled_points) >= 2 * W:
            straws = [None] * (len(self.sampled_points) - (2 * W))
            for i in xrange(W, len(self.sampled_points) - W):
                straws[i - W] = self.sampled_points[i - W].distance_to(
                                            self.sampled_points[i + W])
            t = float(sum(straws)) / float(len(straws)) * 0.95
            for i in xrange(W, len(self.sampled_points) - W):
                if straws[i - W] < t:
                    localMin = float("inf")
                    localMinIndex = i
                    while i < len(straws) and straws[i - W] < t:
                        if straws[i - W] < localMin:
                            localMin = straws[i - W]
                            localMinIndex = i
                        i += 1
                    self.corners.append(localMinIndex)
            self.corners.append(len(self.sampled_points) - 1)
            self.corners = [ii for n, ii in enumerate(self.corners)
                            if ii not in self.corners[:n]]
            self.post_process_corners()

    ''' Identify wrong corners or missed ones. '''
    def post_process_corners(self):
        continuar = False
        while not continuar:
            continuar = True
            for i in xrange(1, len(self.corners)):
                c1 = self.corners[i - 1]
                c2 = self.corners[i]
                if self.is_line(c1, c2):
                    new_corner = self.halfway_corner(self.corners[:], c1, c2)
                    if new_corner > c1 and new_corner < c2:
                        self.corners.insert(i, new_corner)
                        continuar = False
        del_indexes = []
        for i in xrange(1, len(self.corners) - 1):
            c1 = self.corners[i - 1]
            c2 = self.corners[i + 1]
            if self.is_line(c1, c2):
                del_indexes.append(self.corners[i])
        self.corners = [i for j, i in enumerate(self.corners)
                        if j not in del_indexes]

    ''' Returns whether there is a line between two points. '''
    def is_line(self, a, b):
        threshold = 0.95
        distance = self.sampled_points[a].distance_to(self.sampled_points[b])
        pathdistance = self.path_distance(a, b)
        if (distance / pathdistance) > threshold:
            return True
        else:
            return False

    def path_distance(self, a, b):
        d = 0.0
        for i in xrange(a, b):
            d = d + self.sampled_points[i].distance_to(
                                            self.sampled_points[i + 1])
        return d

    ''' Function to evaluate if there is anny corner missed by false
        corner detection. '''
    def halfway_corner(self, corners, a, b):
        quarter = (b - a) / 2
        minValue = float("inf")
        minIndex = -1
        for i in xrange(a + quarter, b - quarter - 1):
            if corners[i] < minValue:
                minValue = corners[i]
                minIndex = i
        return minIndex


class StrokeCanvasBehavior(object):
    '''StrokeCanvas behavior.

    :Events:
        `on_stroke_added`
            Fired when a stroke is drawn in the canvas.
        `on_stroke_removed`
            Fired when a stroke is removed from the canvas.

    .. versionadded:: 1.9.0

    '''

    strokes = ListProperty([])
    '''List of strokes present on the StrokeCanvas.

    :attr:`strokes` is a :class:`~kivy.properties.ListProperty` with no
    elements initially.
    '''

    mode = OptionProperty("draw", options=["draw", "erase", "touch"])
    '''Different modes available on the StrokeCanvas.

    :attr:`mode` is a :class:`~kivy.properties.OptionProperty` with value
    draw by default.
    '''

    stroke_color = StringProperty('black')
    '''Color of the stroke rendered on the StrokeCanvas.

    :attr:`stroke_color` is a :class:`~kivy.properties.StringProperty` with
    value black by default.
    '''

    stroke_width = NumericProperty(1.0)
    '''Width of the stroke rendered on the StrokeCanvas.

    :attr:`stroke_width` is a :class:`~kivy.properties.NumericProperty` with
    value 1.0 by default.
    '''

    stroke_visibility = BooleanProperty(True)
    '''Defines whether a Stroke is visible or not.

    :attr:`stroke_visibility` is a :class:`~kivy.properties.BooleanProperty`
    with value True by default.
    '''

    stroke_opacity = NumericProperty(1.0)
    '''Set the alpha value of the stroke rendered on the StrokeCanvas.

    :attr:`stroke_opacity` is a :class:`~kivy.properties.NumericProperty` with
    value 1.0 by default.
    '''

    __events__ = ('on_stroke_added', 'on_stroke_removed')

    def __init__(self, **kwargs):
        super(StrokeCanvasBehavior, self).__init__(**kwargs)

    def on_touch_down(self, touch):
        '''Receive a touch down event and check the mode of the StrokeCanvas.
        If the mode is draw initializes a Stroke object and starts to draw a
        line with the point created from the touch.
        if the mode is erase, it will check if it colides with any stroke
        already present on the StrokeCanvas, if so it will delete the stroke.
        '''
        if super(StrokeCanvasBehavior, self).on_touch_down(touch):
            return True
        if self.collide_point(*touch.pos):
            touch.grab(self)
            ud = touch.ud
            ud['group'] = g = str(touch.uid)
            pt = StrokePoint(touch.x, touch.y)
            if self.mode == 'draw':
                stroke = Stroke(group_id=g)
                stroke.color = self.stroke_color
                stroke.is_highlighter(self.stroke_opacity)
                stroke.visibility(self.stroke_visibility)
                stroke.points.append(pt)
                touch.ud['stroke'] = stroke
                '''Calculate stroke_point size according to pressure'''
                #if 'pressure' in touch.profile:
                with self.canvas:
                    Color(*stroke._color)
                    touch.ud['line'] = Line(points=(pt.x, pt.y),
                                            width=self.stroke_width, group=g)
            elif self.mode == 'erase':
                self.remove_stroke(pt)

    def on_touch_move(self, touch):
        '''Receive a touch down event and check the mode of the StrokeCanvas.
        If the mode is draw new touches will be created as Points and added to
        the Stroke. A graphic line will de displayed on the StrokeCanvas.
        if the mode is erase, it will check if it colides with any stroke
        already present on the StrokeCanvas, if so it will delete the stroke.
        '''
        if super(StrokeCanvasBehavior, self).on_touch_move(touch):
            return True
        if touch.grab_current is self:
            pt = StrokePoint(touch.x, touch.y)
            if self.mode == 'draw':
                touch.ud['stroke'].points.append(pt)
                touch.ud['line'].points += [pt.x, pt.y]
            elif self.mode == 'erase':
                self.remove_stroke(pt)

    def on_touch_up(self, touch):
        '''Receive a touch down event and check the mode of the StrokeCanvas.
        If the mode is draw the last touch will be added as a Point to the
        Stroke and the Stroke added to the StrokeCanvas.
        if the mode is erase, it will do nothing.
        '''
        if touch.grab_current is self:
            pt = StrokePoint(touch.x, touch.y)
            if self.mode == 'draw':
                touch.ud['stroke'].points.append(pt)
                self.add_stroke(touch.ud['stroke'])
                touch.ud['stroke'].sample_points()
                touch.ud['stroke'].get_corners()

                for c in touch.ud['stroke'].corners:
                    with self.canvas:
                        Color(0.0, 0.0, 1.0, 1.0)
                        Ellipse(pos=(touch.ud['stroke'].sampled_points[c].x,
                                     touch.ud['stroke'].sampled_points[c].y),
                                     size=(10, 10))

                points_list = touch.ud['stroke'].filtering()
                with self.canvas:
                    Color(1, 1, 0)
                    Line(points=touch.ud['stroke'].get_graphics_line_points(),
                         width=1.0)
            elif self.mode == 'erase':
                pass
            touch.ungrab(self)
        else:
            return super(StrokeCanvasBehavior, self).on_touch_up(touch)

    def add_stroke(self, stroke):
        '''Add a stroke to the list of strokes
        '''
        self.strokes.append(stroke)
        self.dispatch('on_stroke_added', stroke)

    def remove_stroke(self, pt):
        '''Remove a stroke from the list of strokes'''
        for stroke in self.strokes:
            if stroke.hit_test(pt):
                self.canvas.remove_group(stroke.group_id)
                self.dispatch('on_stroke_removed', stroke)
                if stroke in self.strokes:
                    self.strokes.remove(stroke)

    def on_stroke_added(self, stroke):
        '''Receive a stroke object that has been added to the StrokeCanvas.

        :Parameters:
            `stroke`: :class:`~kivy.uix.inkcanvas.Stroke` class
                Stroke received. The stroke contains a list of points in <x,y>.
        '''
        pass

    def on_stroke_removed(self, stroke):
        '''Receive a stroke object that has been removed from the
        StrokeCanvas.

        :Parameters:
            `stroke`: :class:`~kivy.uix.inkcanvas.Stroke` class
                Stroke received. The stroke contains a list of points in <x,y>.
        '''
        pass
